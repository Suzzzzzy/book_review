# Slice

slice: Go언어에서 제공하는 동적 배열(자동으로 배열 크기를 증가시키는 자료구조)

- 일반적인 배열은 정한 길이에서 더 이상 늘어나지 않는 문제점이 있다
- `var array [10]int`이렇게 배열을 만들면 최대 10개까지 값을 저장할 수 있고
- 10개 보다 많은 값을 저장하려면 더 큰 배열을 만들어서 값을 하나씩 복사해야 한다
- 그러나 슬라이스는 배열의 개수를 정하지 않고 선언

# 요소 추가

- 배열은 길이를 늘릴 수 없지만, 슬라이스는 요소를 추가하여 길이를 늘릴 수 있다
- `append()`내장 함수를 사용 - 슬라이스 맨 뒤에 요소를 추가
- append() 함수가 호출되면, **cap(실제 배열의 길이) - len(요소의 개수)** 를 확인하여 빈공간 확인
    - 남은 빈 공간이 없을 경우 배열 뒷부분에 값을 추가한 뒤 len 증가시킴

# 슬라이스 동작 원리

```go
type SliceHeader struct {
	Data uintptr // 실제 배열을 가리키는 포인터
	Len int // 요소 개수
	Cap int // 실제 배열의 길이
```

- 슬라이스가 실제 배열을 가리키는 포인터를 가지고 있음 → 쉽게 크기가 다른 배열을 가리키도록 변경할 수 있다
- 슬라이스 변수 대입 시 배열에 비해 사용되는 메모리나 속도에 이점이 있다

# slice, 배열 동작 차이

go 언어에서는 모든 값의 대입은 **복사**로 일어난다 → 함수에 인수로 전달될 때나 다른 변수에 대입할 때 값의 이동은 **복사**로 일어난다

→ 포인터는 포인터의 값인 메모리 주소가 복사되고, 구조체가 복사될 때는 구조체의 모든 필드가 복사된다

```go
func changeArray(array2 [5]int) {
	array2[2] = 200
}

func changeSlice(slice []int) {
	slice2[2] = 200
}
```

- chageArray() 함수에 array를 입력하면 array2로 모든 값이 복사된다
    - 따라서 array2를 변경해도 array와는 다른 배열이기 대문에 array배열 자체는 변경되지 않는다
- changeSlice() 함수는 배열의 메모리 주소(포인터)값이 복사되므로 실제 배열은 같고, 해당 배열의 값이 변경된다

# slice 예기치 못한 문제

## 같은 배열을 가리키는 포인터
```go
slice2 := append(slice1, 4, 5)
slice1[1] = 100
```
- slice1과 slice2는 같은 배열을 가리키고 있다
- slice1 배열의 두번째 값을 100으로 변경하게 된다면 slice1과 slice2 모두가 변경된다

## append() 사용
- append() 함수가 호출될 때 빈공간이 충분하지 않다면, 일반적으로 기존 배열의 2배 큰 배열을 만들고 기존의 값을 새로운 큰 배열에 복사한다
- 그에 따라 cap, len 값은 확장된다
```go
slice1 := []int{1, 2, 3}
slice2 := append(slice, 4, 5)
```
- slice1은 len:3, cap:3 슬라이스이므로 4, 5를 추가하게 되면 빈공간이 없어 6개짜리 새로운 배열을 만든 뒤 slice 배열의 모든 값을 복사하고 맨뒤에 4,5를 추가해서 새로운 배열 반환
- 따라서 새로운 slice2와 slice1은 다른 배열을 가리키고 있다

# 슬라이싱
슬라이스는 배열을 가리키는 포인터로 구성되어 있기 때문에, 얼마든지 배열의 중간을 가리킬 수 있다 -> 슬라이싱 하게되면 포인터가 해당 배열의 중간 값을 가리키게 되는 것
```go
slice1 := []intt{1, 2, 3, 4, 5}
slice2 := slice1[1:2] // slice2는 [2]
```
- slice2는 slice1이 가리키는 배열의 시작인덱스 1인 두 번째 요소를 가리키는 슬라이스
- slice1 len:5, cap:5
- slice2 len:1, cap:4 (slice1이 요소5개인 배열을 가리키고, 요소의 개수가 1개이므로 5-1=4 )
- 슬라이싱할 때 세번째 인덱스를 생략하면 위와 같이 배열의 전체 길이를 다 사용하게 된다

```go
slice1 := []intt{1, 2, 3, 4, 5}
slice2 := slice1[1:2:4]
// slice[ 시작인덱스 : 끝인덱스 : 최대인덱스]
```
- cap = 최대인덱스 - 시작인덱스
- 배열의 전체 길이를 다 사용하지 않고 최대 인덱스 까지만 배열을 사용하게 된다
- slice2 len:2, cap:3 (4-1=3)

# 요소 삭제
중간 요소를 삭제할 경우 - 삭제하고 이후의 값을 앞당겨서 삭제한 요소를 채워야 한다

append()사용하여 쉽게 표현 가능
```go
slice = append(slice[:idx], slice[idx+1:]...)
```
- 삭제 요소 이전 슬라이싱한 슬라이스와 삭제요소 이후 슬라이싱한 슬라이스를 붙이는 것

# 요소 추가
중간에 요소를 추가하게 될 경우 - 맨 뒤에 요소를 추가하고 하나씩 뒤로 복사하여 추가하고자 하는 인덱스의 값을 수정

append() 함수 사용
```go
slice = append(slice[:idx], append([]int{100}, slice[idx:]...)...)
```
- 삽입하려는 요소의 이전 슬라이스에 삽입 요소, 이후의 슬라이스를 더한다

불필요한 메모리 사용이 없도록 코드 개선
```go
slice = append(slice, 0) // 맨위데 요소 추가
COPY(slice[idx+1:], slice[idx:]) // 값 복사
slice[idx] = 100 // 값 변경
```
- COPY(복사하는 위치, 복사하려는 대상) - 추가하고자 하는 idex 이후의 값들을 idex+1 이후로 복사한다(한 칸씩 뒤로 복사)

# 슬라이스 정렬
