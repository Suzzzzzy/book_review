# 고루틴과 동시성 프로그래밍
GoRoutine
- Go언어에서 관리하는 경량 스레드, 함수나 명령을 동시에 수행할 때 사용
- 프로그램의 시작점인 min()함수도 고루틴에 의해 실행됨
- 명령을 수행하는 단일 흐름
- OS 스레드(운영체제가 제공하는)를 이용하는 경량 스레드

동시성 프로그래밍: 여러 고루틴을 갖는 프로그램을 코딩하는 것

## 스레드
- 프로세스: 메모리 공간에 로딩되어 동작하는 프로그램
- 스레드: 프로세스 안의 내부 작업 단위 -> 실행 흐름
- CPU 코어는 한 번에 한 명령밖에 수행할 수 없다
- 싱글 코어 CPU에서 스레드를 빠르게 전환해가면서 여러 프로그램을 수행하면 - 동시에 수행하는 것처럼 보인다
  - 스레드가 전환되어 돌아올 때마다 스레드의 컨텍스트(문맥 - 마지막 실행상황)를 저장해야함
  - 따라서 많은 스레드를 수행하면 성능 저하
  - **그러나 go언어는 CPU 코어마다 OS 스레드를 하나만 할당해서 사용하기 때문에 컨텍스트 스위칭 비용이 발생하지 않음**

## 고루틴 사용
- 모든 프로그램은 고루틴을 최소 하나는 가지고 있다 -> 메인루틴! main()
- 이 고루틴은 main() 함수와 함께 시작되고, main() 함수가 종료되면 종료
- 메인 루틴이 종료되면 아무리 많은 고루틴이 생성되어 있다고 해도 프로그램 또한 종료
- 고루틴이 3개라고 할 때, 코어의 개수가 3개 이상이 되지 않으면 코어가 부족해서 동시에 실행되지는 않음

### 서브 고루틴 종료 기다리기
```go
var wg sync.WaitGroup

wg.Add(3) // 작업 개수 설정
wg.Done() // 작업이 완료될 때마다 호출
wg.Wait() // 모든 작업이 완료될 때까지 대기
```
- Add() 메서드를 통해 완료해야하는 작업 개수 설정
- 작업이 완료될 때마다 Done() 호출하여 남은 작업 개수 하나씩 줄이기
- Wait() 전체 작업이 모두 완료될 때까지 대기

## 고루틴 동작 방법
- OS 스레드를 통해서 CPU 코어에서 실행
- Go로 만든 프로그램 역시 OS 위에서 돌아가기 때문에 명령을 수행하려면 OS 스레드를 만들어서 명령을 실행
- 모든 명령은 OS 스레드를 통해 CPU 코어에서 실행 됨
- 한개의 고루틴이 존재한다면(main) - 명령을 수행하기 위해 OS스레드를 만들어 명령을 실행 - OS스레드와 첫번째 코어 연결 - OS스레드에서 고루틴 실행
- 두개의 코더만 존재하는데, 3개의 고루틴이 생성될 경우 - 고루틴3은 스레드를 만들지 않고 다 실행되어 남는 코어가 생길때 까지 실행되지 않고 기다림
- 장점
  - 코어와 스레드는 변경되지 않고 고루틴만 옮겨다니기 때문에 컨텍스트 스위칭 비용 발생 X
  - 수백, 수천 고루틴 만들어서 사용 가능

## 동시성 프로그래밍 주의점
- 동일한 메모리 자원에 여러 고루틴이 접근할 때 발생

## 뮤텍스를 이용한 동시성 문제 해결
- 한 고루틴에서 값을 변경할 때, 다른 고루틴이 건들지 못하게 하면 됨!
- mutex: 상호배제 -> 뮤텍스를 획득한 고루틴만 가능
- 한 번 획득한 뮤텍스는 반드시 Unlock()을 호출하여 반납해야함
```go
func DepositAndWithdraw(account *Account) {
	mutex.Lock() // 뮤텍스를 확보할 때 까지 대기
	defer mutex.Unlock() // 여기 부터 뮤텍스를 확보한 하나의 고루틴만 실행하게 됨
	account.Balance += 1000
	time.Sleep(time.Millisecond)
}
```

## 뮤텍스와 데드락  
동시성 프로그래밍 문제를 해결할 수 있지만, 또 다른 문제 발생할 수 있다
- 동시성 프로그래밍으로 얻는 성능 향상은 얻을 수 없다
  - 뮤텍스는 하나의 고루틴만 공유 자원에 접근할 수 있도록 제한 -> 한개의 고루틴만 실행됨 -> 성능향상을 위한 동시성 프로그램 장점 살리지 못함
- 데드락(프로그램을 완전히 멈추게 만드는 것) 발생할 수 있다
  - 어떤 고루틴도 원하는 만큼 뮤텍스를 확보하지 못해 무한히 대기하게 되는 경우