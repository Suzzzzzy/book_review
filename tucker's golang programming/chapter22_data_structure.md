# 자료구조
자료구조: 여러 데이터를 저장하는 구조

- 배열: 연속된 메모리에 데이터를 저장
- 리스트: 비연속 메모리를 사용해 요소를 저장 
  - 요소 삽입과 삭제가 배열보다 빠름
- 큐: 먼저 입력한 요소가 먼저 출력
- 스택: 마지막에 입력한 요소가 먼저 출력
- 링: 처음과 끝이 연결된 리스트, 크기가 고정된 리스트
- 맵: 키와 값 형태로 자료가 저장

## 리스트
- 요소들이 포인터로 연결되어 있음 = linked list
```go
// 리스트 구조체
type Element struct {
	Value interface{} // 데이터
	Next *Element // 다음 요소의 주소
	Prev *Element // 이전 요소의 주소
}
```
- 이전요소와 다음 요소에 접근 할 수 있음 -> 양방향 리스트
- 이렇게 떨어진 요소들이 Next 포인터로 연결된 불연속 자료구조

## 배열 vs 리스트
1. 맨 앞에 데이터 추가할 때
- 배열: 각 요소를 한 칸씩 뒤로 밀고 맨 앞의 값 변경
- 리스트: 맨 앞에 요소 추가하고 연결만 만들어주면 됨(node)

2. 특정 요소에 접근
- 배열: 배열 시작 주소 + (인데스 X 타입 크기) O(1)
- 리스트: 요소가 연결되어 있기 때문에 앞 요소들을 모두 거쳐야 접근 가능 O(N)

3. 데이터의 지역성: 데이터가 밀집한 정도
- 배열: 연속된 메모리 - 지역성 좋음 - 요수 수가 적으면 삽입과 삭제가 리스트보다 효율적
- 리스트: 불연속 메모리 - 지역성 안좋음 - 요소 수가 많으면 삽입과 삭제가 빈번할 때 배열보다 효율적

4. 스택과 큐 구현
- 배열: 스택은 요소의 추가와 삭제가 맨 뒤에서 발생하기 때문에 배열로 만들어도 성능 손해가 없다
- 리스트: 큐는 삭제는 맨 앞, 추가는 맨 뒤에서 발생하기 때문에 리스트가 더 효율적 - 삭제할 때 O(1), 배열로 구현하면 O(N)

## 링
- 맨 뒤의 요소와 맨 앞의 요소가 서로 연결
- 시작과 끝이 없는 대신, 현재 위치만 있다
- 저장할 개수가 고정될 때 사용
- ex. 실행 취소, 고정 크기 버퍼 기능(데이터에 따라 버퍼 증가되지 않고 고정된 길이로 사용), 리플레이 기능

## 맵
- 키와 값 형태로 데이터를 저장하는 자료구조
- = 딕셔너리, 해시테이블, 해시맵 ..
- 키를 이용해 데이터에 접근하여 값을 저장, 변경
```go
v, ok := m["key"]
```
- ok로 요소 존재 여부도 알 수 있다(bool)
- 추가, 삭제, 읽기 모두 속도가 O(1)