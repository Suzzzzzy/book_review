# Method
- 함수의 일종
- Go 언어는 클래스가 없기 때문에 구조체 밖에 메서드를 지정 - 이 때 리시버 사용
- 리시버: 메서드가 어느 구조체에 속하는지 표시

## method 선언
```go
type account struct {
	balancd int
}
// 일반 함수 표현
func withdrawFunc(a *account, amout int) {
	a.balance -= amount
}
// 메서드 표현
func (a *account) withdrawMethod(amount int) {
	a.balace -= amout
}

func main() {
	a := &account{100}
	// 함수 형태 호출
	withdrawFunc(a, 30)
	// 메서드 형태 호출
	a.withdrawMethod(30)
}
```

## 메서드는 왜 필요한가?
- 소속 - 일반 함수는 어디에도 속하지 않지만 메서드는 리시버에 속한다
- 좋은 프로그래밍이란 결합도를 낮추고 응집도를 높여야 한다
- 메서드는 **데이터와 관련 기능**을 묶기 때문에 코드 응집도를 높이는 중요한 역할을 한다
- 묶여있기 때문에 코드 수정범위가 줄어든다
- 메서드가 등장하기 전에는 **절차 중심의 프로그래밍**(데이터와 기능이 분리되어 기능의 순서로 정의한 것)
- 메서드가 생기고나서는 **관계 중심 프로그래밍**(데이터와 기능이 묶인 단일 객체로 동작)
- 객체 간 관계 중심 프로그래밍 패러다임 변화 -> 객체지향 프로그래밍 OOP

> Go는 클래스와 상속을 지원하지 않으므로 OOP언어가 아닌가?  
> tucker는 OOP언어는 클래스와 상속 지원 유무가 아닌 객체 간의 상호관계 중심 프로그래밍의 여부 이므로  
> 메서드와 인터페이스를 지원하는 Go언어는 충분한 OOP라고 생각한다

## 포인터 메서드 VS 값 타입 메서드
### 포인터 메서드
- `func (a *account) withdraw(){}`
- 인스턴스 중심으로 메서드에서 호출자 인스턴스에 접근하여 값 변경
- 내부에서 리시버의 값을 변경시킬 수 있다

### 값 타입 메서드
- `func (a account) withdraw(){}`
- 호출 시 값이 모두 복사돈다
- 호출하는 쪽과 메서드 내부의 값은 별도 인스턴스로 독립
- 메서드 내부에서 리시버의 값을 변경시킬 수 없다 (구조체가 복사되기 때문에 다른 메모리 주소를 갖는 서로 다른 객체이기 떄문)
- 복사되는 양에 따라 성능상 문제가 될 수 있다